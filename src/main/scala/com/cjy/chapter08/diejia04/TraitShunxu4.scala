package com.cjy.chapter08.diejia04

/**
  * 8.4.9 特质构造顺序，分为两种：1. 声明构造
  *                         2. 构建对象时，动态混入
  *
  *
  * 第一种特质构造顺序：
  *1. 调用当前类的超类构造器
  *2. 第一个特质的父特质构造器
  *3. 第一个特质构造器
  *4. 第二个特质构造器的父特质构造器, 如果已经执行过，
  * 就不再执行
  *5. 第二个特质构造器
  *6. .......重复 4,5 的步骤(如果有第 3 个，第 4 个特质)
  *7.当前类构造器
  *
  * *********************************
  * 第二种特质构造顺序：
  *1. 调用当前类的超类构造器
  *2. 当前类构造器
  *3. 第一个特质构造器的父特质构造器
  *4. 第一个特质构造器.
  *5. 第二个特质构造器的父特质构造器, 如果已经执行过，就不再执行
  *6. 第二个特质构造器
  *7. .......重复 5,6 的步骤(如果有第 3 个，第 4 个特质)
  *
  * *********************************
  * 分析两种方式对构造顺序的影响
  * 第 1 种方式实际是构建类对象, 在混入特质时， 该对象还没有创建。
  * 第 2 种方式实际是构造匿名子类，可以理解成在混入特质时，对象已经创建了
  */
object TraitShunxu4 {
  def main(args: Array[String]): Unit = {
    //先执行当前父类构造与当前特质父特质与特质的构造，按照顺序从左到右依次执行，最后是当前类构造
//      val f1 = new FF
    //先执行当前父类与当前构造，在执行后面特质的父特质及特质，按照从左到右顺序
    val f2 = new KK with CC with DD
  }
}

trait AA {
  println("A...")
}
trait BB extends AA {
  println("B....")
}
trait CC extends BB {
  println("C....")
}
trait DD extends BB {
  println("D....")
}
class EE { //普通类
  println("E...")
}
class FF extends EE with CC with DD { //先继承了 EE 类，然后再继承 CC 和 DD
  println("F....")
}
class KK extends EE { //KK 直接继承了普通类 EE
  println("K....")
}

